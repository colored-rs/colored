diff --git a/src/lib.rs b/src/lib.rs
index 54b234f..1f5ead3 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -23,6 +23,10 @@
 //!
 //! See [the `Colorize` trait](./trait.Colorize.html) for all the methods.
 //!
+//! Note: The methods of [`Colorize`], when used on [`str`]'s, return
+//! [`ColoredString`]'s. See [`ColoredString`] to learn more about them and
+//! what you can do with them beyond continue to use [`Colorize`] to further
+//! modify them.
 #![warn(missing_docs)]
 
 extern crate is_terminal;
@@ -43,17 +47,114 @@ pub mod customcolors;
 
 pub use color::*;
 
-use std::{borrow::Cow, fmt, ops::Deref};
+use std::{
+    borrow::Cow,
+    fmt,
+    ops::{Deref, DerefMut},
+};
 
 pub use style::{Style, Styles};
 
 /// A string that may have color and/or style applied to it.
-#[derive(Clone, Debug, PartialEq, Eq)]
+///
+/// Commonly created via calling the methods of [`Colorize`] on a &str.
+/// All methods of [`Colorize`] either create a new `ColoredString` from
+/// the type called on or modify a callee `ColoredString`. See
+/// [`Colorize`] for more.
+///
+/// The primary usage of `ColoredString`'s is as a way to take text,
+/// apply colors and miscillaneous styling to it (such as bold or
+/// underline), and then use it to create formatted strings that print
+/// to the console with the special styling applied.
+///
+/// ## Usage
+///
+/// As stated, `ColoredString`'s, once created, can be printed to the
+/// console with their colors and style or turned into a string
+/// containing special console codes that has the same effect.
+/// This is made easy via `ColoredString`'s implementations of
+/// [`Display`](std::fmt::Display) and [`ToString`] for those purposes
+/// respectively.
+///
+/// Printing a `ColoredString` with its style is as easy as:
+///
+/// ```
+/// # use colored::*;
+/// let cstring: ColoredString = "Bold and Red!".bold().red();
+/// println!("{}", cstring);
+/// ```
+///
+/// ## Manipulating the coloring/style of a `ColoredString`
+///
+/// Getting or changing the foreground color, background color, and or
+/// style of a `ColoredString` is as easy as manually reading / modifying
+/// the fields of `ColoredString`.
+///
+/// ```
+/// # use colored::*;
+/// let mut red_text = "Red".red();
+/// // Changing color using re-assignment and [`Colorize`]:
+/// red_text = red_text.blue();
+/// // Manipulating fields of `ColoredString` in-place:
+/// red_text.fgcolor = Some(Color::Blue);
+///
+/// let styled_text1 = "Bold".bold();
+/// let styled_text2 = "Italic".italic();
+/// let mut styled_text3 = ColoredString::from("Bold and Italic");
+/// styled_text3.style = styled_text1.style | styled_text2.style;
+/// ```
+///
+/// ## Modifying the text of a `ColoredString`
+///
+/// Modifying the text is as easy as modifying the `input` field of
+/// `ColoredString`...
+///
+/// ```
+/// # use colored::*;
+/// let mut colored_text = "Magenta".magenta();
+/// colored_text = colored_text.blue();
+/// colored_text.input.replace_range(.., "Blue");
+///
+/// assert_eq!(&**colored_text, "Blue");
+/// ```
+///
+/// `ColoredString` implements [`Deref<String>`] and [`DerefMut`]. This
+/// allows you not only to use all the methods of [`String`] but also
+/// those of [`str`]. It also lets you replace the underlying string
+/// via deref assigning in addition to being able to set the `input`
+/// field which can be useful for some cases involving trait objects.
+///
+/// ```
+/// # use colored::*;
+/// let mut blue_string = "This is Blue! Blue, Blue, Blue!!".blue();
+///
+/// // Blue is an ugly color, I prefer green.
+/// blue_string = blue_string.green();
+///
+/// // We should probably change the text to reflect the new style:
+/// *blue_string = // <- mutably dereferencing ColoredString as a String
+///     blue_string.replace("Blue", "Green"); // <- using a method of str on ColoredString.
+/// assert_eq!(blue_string, "This is Green! Green, Green, Green!!".green());
+///
+/// // We should also probably remove the extra exclamation mark; this is the color
+/// // green we're talking about, we don't need to sound so emphatic about it.
+/// blue_string.pop(); // <- using a method of String on ColoredString.
+/// assert_eq!(blue_string, "This is Green! Green, Green, Green!".green());
+/// ```
+///
+/// Notice how this process preserves the coloring and style.
+#[derive(Clone, Debug, Default, PartialEq, Eq)]
 pub struct ColoredString {
-    input: String,
-    fgcolor: Option<Color>,
-    bgcolor: Option<Color>,
-    style: style::Style,
+    /// The plain text that will have color and style applied to it.
+    pub input: String,
+    /// The color of the text as it will be printed.
+    pub fgcolor: Option<Color>,
+    /// The background color (if any). None means that the text will be printed
+    /// without a special background.
+    pub bgcolor: Option<Color>,
+    /// Any special styling to be applied to the text (see Styles for a list of
+    /// available options).
+    pub style: style::Style,
 }
 
 /// The trait that enables something to be given color.
@@ -339,6 +440,7 @@ impl ColoredString {
     /// let cstr = cstr.clear();
     /// assert_eq!(cstr.fgcolor(), None);
     /// ```
+    #[deprecated(note = "Deprecated due to the exposing of the fgcolor struct field.")]
     pub fn fgcolor(&self) -> Option<Color> {
         self.fgcolor.as_ref().copied()
     }
@@ -352,6 +454,7 @@ impl ColoredString {
     /// let cstr = cstr.clear();
     /// assert_eq!(cstr.bgcolor(), None);
     /// ```
+    #[deprecated(note = "Deprecated due to the exposing of the bgcolor struct field.")]
     pub fn bgcolor(&self) -> Option<Color> {
         self.bgcolor.as_ref().copied()
     }
@@ -365,10 +468,28 @@ impl ColoredString {
     /// assert_eq!(colored.style().contains(Styles::Italic), true);
     /// assert_eq!(colored.style().contains(Styles::Dimmed), false);
     /// ```
+    #[deprecated(note = "Deprecated due to the exposing of the style struct field.")]
     pub fn style(&self) -> style::Style {
         self.style
     }
 
+    /// Clears foreground coloring on this `ColoredString`, meaning that it
+    /// will be printed with the default terminal text color.
+    pub fn clear_fgcolor(&mut self) {
+        self.fgcolor = None;
+    }
+
+    /// Gets rid of this `ColoredString`'s background.
+    pub fn clear_bgcolor(&mut self) {
+        self.bgcolor = None;
+    }
+
+    /// Clears any special styling and sets it back to the default (plain,
+    /// maybe colored, text).
+    pub fn clear_style(&mut self) {
+        self.style = Style::default();
+    }
+
     /// Checks if the colored string has no color or styling.
     ///
     /// ```rust
@@ -461,21 +582,16 @@ impl ColoredString {
     }
 }
 
-impl Default for ColoredString {
-    fn default() -> Self {
-        ColoredString {
-            input: String::default(),
-            fgcolor: None,
-            bgcolor: None,
-            style: style::CLEAR,
-        }
+impl Deref for ColoredString {
+    type Target = String;
+    fn deref(&self) -> &String {
+        &self.input
     }
 }
 
-impl Deref for ColoredString {
-    type Target = str;
-    fn deref(&self) -> &str {
-        &self.input
+impl DerefMut for ColoredString {
+    fn deref_mut(&mut self) -> &mut String {
+        &mut self.input
     }
 }
 
@@ -849,6 +965,8 @@ mod tests {
 
     #[test]
     fn exposing_tests() {
+        #![allow(deprecated)]
+
         let cstring = "".red();
         assert_eq!(cstring.fgcolor(), Some(Color::Red));
         assert_eq!(cstring.bgcolor(), None);
diff --git a/src/style.rs b/src/style.rs
index 8588554..1d66b48 100644
--- a/src/style.rs
+++ b/src/style.rs
@@ -1,3 +1,56 @@
+use core::ops::{BitAnd, BitAndAssign, BitOr, BitOrAssign, BitXor, BitXorAssign, Not};
+
+macro_rules! auto_impl_ref_binop_trait {
+    (impl $trait_name:ident, $method:ident for $t:ty, $u:ty) => {
+        impl $trait_name<&$u> for $t {
+            type Output = <$t as $trait_name<$t>>::Output;
+
+            #[inline]
+            fn $method(self, rhs: &$u) -> Self::Output {
+                $trait_name::$method(self, *rhs)
+            }
+        }
+
+        impl $trait_name<$u> for &$t {
+            type Output = <$t as $trait_name<$t>>::Output;
+
+            #[inline]
+            fn $method(self, rhs: $u) -> Self::Output {
+                $trait_name::$method(*self, rhs)
+            }
+        }
+
+        impl $trait_name<&$u> for &$t {
+            type Output = <$t as $trait_name<$t>>::Output;
+
+            #[inline]
+            fn $method(self, rhs: &$u) -> Self::Output {
+                $trait_name::$method(*self, *rhs)
+            }
+        }
+    };
+}
+
+macro_rules! impl_assign_op_trait {
+    (
+        $trait:ident, $method:ident for $t:ty, using $used_trait:ident::$used_method:ident
+    ) => {
+        impl $trait<$t> for $t {
+            #[inline]
+            fn $method(&mut self, other: $t) {
+                *self = $used_trait::$used_method(&*self, other);
+            }
+        }
+
+        impl $trait<&$t> for $t {
+            #[inline]
+            fn $method(&mut self, other: &$t) {
+                *self = $used_trait::$used_method(&*self, other);
+            }
+        }
+    };
+}
+
 const CLEARV: u8 = 0b0000_0000;
 const BOLD: u8 = 0b0000_0001;
 const UNDERLINE: u8 = 0b0000_0010;
@@ -22,9 +75,123 @@ static STYLES: [(u8, Styles); 8] = [
 pub static CLEAR: Style = Style(CLEARV);
 
 /// A combinatorial style such as bold, italics, dimmed, etc.
+///
+/// ## Creation
+///
+/// `Style::default()` returns a `Style` with no style switches
+/// activated and is the default method of creating a plain `Style`.
+///
+/// ## `Style` from a set of `Styles`s / `Styles` iterator
+///
+/// `Style` implements `FromIter<Styles>` which means that it is
+/// possible to do the following:
+///
+/// ```rust
+/// # use colored::*;
+/// let style = Style::from_iter([Styles::Bold, Styles::Italic, Styles::Strikethrough]);
+/// for styles in [Styles::Bold, Styles::Italic, Styles::Strikethrough] {
+///     assert!(style.contains(styles));
+/// }
+/// ```
+///
+/// As you can see, this is a good thing to keep in mind, although for
+/// most cases, where you're not setting styles dynamically and are
+/// simply creating a pre-defined set of styles, using [`Default`] and
+/// then using the builder-style methods is likely prettier.
+///
+/// ```rust
+/// # use colored::*;
+/// let many_styles = Style::default()
+///     .bold()
+///     .underline()
+///     .italic()
+///     .blink();
+/// ```
+///
+/// ## Implementation of logical bitwise operators
+///
+/// `Style` implements bitwise logical operations that operate on
+/// the held style switches collectively. By far the most common
+/// and useful is the bitwise 'or' operator `|` which combines two
+/// styles, merging their combined styles into one. Example:
+///
+/// ```rust
+/// # use colored::*;
+/// let only_bold = Style::from(Styles::Bold);
+/// // This line is actually an example of `Styles`'s bitwise logic impls but still.
+/// let underline_and_italic = Styles::Underline | Styles::Italic;
+/// let all_three = only_bold | underline_and_italic;
+///
+/// assert!(all_three.contains(Styles::Bold)
+///     && all_three.contains(Styles::Underline)
+///     && all_three.contains(Styles::Italic));
+/// ```
+///
+/// This functionality also allows for easily turning off styles
+/// of one `Styles` using another by combining the `&` and `!`
+/// operators.
+///
+/// ```rust
+/// # use colored::*;
+/// let mut very_loud_style = Style::default()
+///     .bold()
+///     .underline()
+///     .italic()
+///     .strikethrough()
+///     .hidden();
+///
+/// // Oops! Some of those should not be in there!
+/// // This Style now has all styles _except_ the two we don't want
+/// // (hidden and strikethough).
+/// let remove_mask =
+///     !Style::from_iter([Styles::Hidden, Styles::Strikethrough]);
+/// very_loud_style &= remove_mask;
+///
+/// // `very_loud_style` no longer contains the undesired style
+/// // switches...
+/// assert!(!very_loud_style.contains(Styles::Hidden)
+///     && !very_loud_style.contains(Styles::Strikethrough));
+/// // ...but it retains everything else!
+/// assert!(very_loud_style.contains(Styles::Bold));
+/// ```
 #[derive(Clone, Copy, PartialEq, Eq, Debug)]
 pub struct Style(u8);
 
+/// Enum containing all of the available style settings that can be
+/// applied to a [`Styles`] and by extension, a colrized type.
+///
+/// ## Implementation of bitwise logical operators
+///
+/// The implementations of [`BitAnd`], [`BitOr`], [`BitXor`], and
+/// [`Not`] are really extensions of [`Style`]'s implementations of
+/// the same. [`BitOr`] is great for starting chains of `Styles`'s
+/// for creating [`Style`]'s.
+///
+/// ```
+/// # use colored::*;
+/// let my_styles =
+///     // BitOr<Styles> for Styles (Styles | Styles) = Style
+///     Styles::Bold | Styles::Underline
+///     // BitOr<Styles> for Style (Style | Styles) = Style
+///     | Styles::Italic;
+///
+/// for s in [Styles::Bold, Styles::Underline, Styles::Italic] {
+///     assert!(my_styles.contains(s));
+/// }
+/// ```
+///
+/// [`Not`] has far fewer use cases but can still find use in
+/// turning a `Styles` into a [`Style`] with all styles activated
+/// except that `Styles`.
+///
+/// ```
+/// # use colored::*;
+/// let everything_but_bold = !Styles::Bold;
+///
+/// assert!(everything_but_bold.contains(Styles::Underline));
+/// assert!(everything_but_bold.contains(Styles::Strikethrough));
+/// assert!(!everything_but_bold.contains(Styles::Bold));
+/// ```
 #[derive(Clone, Copy, PartialEq, Eq, Debug)]
 #[allow(missing_docs)]
 pub enum Styles {
@@ -86,15 +253,91 @@ impl Styles {
     }
 }
 
+impl BitAnd<Styles> for Styles {
+    type Output = Style;
+
+    fn bitand(self, rhs: Styles) -> Self::Output {
+        Style(self.to_u8() & rhs.to_u8())
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitAnd, bitand for Styles, Styles);
+
+impl BitAnd<Style> for Styles {
+    type Output = Style;
+
+    fn bitand(self, rhs: Style) -> Self::Output {
+        Style(self.to_u8() & rhs.0)
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitAnd, bitand for Styles, Style);
+
+impl BitOr<Styles> for Styles {
+    type Output = Style;
+
+    fn bitor(self, rhs: Styles) -> Self::Output {
+        Style(self.to_u8() | rhs.to_u8())
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitOr, bitor for Styles, Styles);
+
+impl BitOr<Style> for Styles {
+    type Output = Style;
+
+    fn bitor(self, rhs: Style) -> Self::Output {
+        Style(self.to_u8() | rhs.0)
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitOr, bitor for Styles, Style);
+
+impl BitXor<Styles> for Styles {
+    type Output = Style;
+
+    fn bitxor(self, rhs: Styles) -> Self::Output {
+        Style(self.to_u8() ^ rhs.to_u8())
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitXor, bitxor for Styles, Styles);
+
+impl BitXor<Style> for Styles {
+    type Output = Style;
+
+    fn bitxor(self, rhs: Style) -> Self::Output {
+        Style(self.to_u8() ^ rhs.0)
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitXor, bitxor for Styles, Style);
+
+impl Not for Styles {
+    type Output = Style;
+
+    fn not(self) -> Self::Output {
+        Style(!self.to_u8())
+    }
+}
+
+impl Not for &Styles {
+    type Output = Style;
+
+    fn not(self) -> Self::Output {
+        Style(!self.to_u8())
+    }
+}
+
 impl Style {
     /// Check if the current style has one of [`Styles`](Styles) switched on.
     ///
     /// ```rust
     /// # use colored::*;
     /// let colored = "".bold().italic();
-    /// assert_eq!(colored.style().contains(Styles::Bold), true);
-    /// assert_eq!(colored.style().contains(Styles::Italic), true);
-    /// assert_eq!(colored.style().contains(Styles::Dimmed), false);
+    /// assert_eq!(colored.style.contains(Styles::Bold), true);
+    /// assert_eq!(colored.style.contains(Styles::Italic), true);
+    /// assert_eq!(colored.style.contains(Styles::Dimmed), false);
     /// ```
     pub fn contains(self, style: Styles) -> bool {
         let s = style.to_u8();
@@ -110,9 +353,198 @@ impl Style {
             .join(";")
     }
 
-    pub(crate) fn add(&mut self, two: Styles) {
+    /// Adds the `two` style switch to this Style.
+    ///
+    /// ```rust
+    /// # use colored::*;
+    /// let cstr = "".red().bold();
+    /// let mut style = cstr.style;
+    /// style.add(Styles::Italic);
+    /// let mut cstr2 = "".blue();
+    /// cstr2.style = style;
+    ///
+    /// assert!(cstr2.style.contains(Styles::Bold));
+    /// assert!(cstr2.style.contains(Styles::Italic));
+    /// assert_eq!(cstr2.fgcolor, Some(Color::Blue));
+    /// ```
+    pub fn add(&mut self, two: Styles) {
         self.0 |= two.to_u8();
     }
+
+    /// Turns off a style switch.
+    ///
+    /// ```rust
+    /// use colored::*;
+    /// let cstr = "".red().bold().italic();
+    /// let mut style = cstr.style;
+    /// style.remove(Styles::Italic);
+    /// let mut cstr2 = "".blue();
+    /// cstr2.style = style;
+    /// assert!(cstr2.style.contains(Styles::Bold));
+    /// assert!(!cstr2.style.contains(Styles::Italic));
+    /// assert_eq!(cstr2.fgcolor, Some(Color::Blue));
+    /// ```
+    pub fn remove(&mut self, two: Styles) {
+        self.0 &= !two.to_u8();
+    }
+
+    /// Makes this `Style` include Bold.
+    pub fn bold(mut self) -> Self {
+        self.add(Styles::Bold);
+        self
+    }
+
+    /// Makes this `Style` include Dimmed.
+    pub fn dimmed(mut self) -> Self {
+        self.add(Styles::Dimmed);
+        self
+    }
+
+    /// Makes this `Style` include Underline.
+    pub fn underline(mut self) -> Self {
+        self.add(Styles::Underline);
+        self
+    }
+
+    /// Makes this `Style` include Reversed.
+    pub fn reversed(mut self) -> Self {
+        self.add(Styles::Reversed);
+        self
+    }
+
+    /// Makes this `Style` include Italic.
+    pub fn italic(mut self) -> Self {
+        self.add(Styles::Italic);
+        self
+    }
+
+    /// Makes this `Style` include Blink.
+    pub fn blink(mut self) -> Self {
+        self.add(Styles::Blink);
+        self
+    }
+
+    /// Makes this `Style` include Hidden.
+    pub fn hidden(mut self) -> Self {
+        self.add(Styles::Hidden);
+        self
+    }
+
+    /// Makes this `Style` include Strikethrough.
+    pub fn strikethrough(mut self) -> Self {
+        self.add(Styles::Strikethrough);
+        self
+    }
+}
+
+impl BitAnd<Style> for Style {
+    type Output = Style;
+
+    fn bitand(self, rhs: Style) -> Self::Output {
+        Style(self.0 & rhs.0)
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitAnd, bitand for Style, Style);
+
+impl BitAnd<Styles> for Style {
+    type Output = Style;
+
+    fn bitand(self, rhs: Styles) -> Self::Output {
+        Style(self.0 & rhs.to_u8())
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitAnd, bitand for Style, Styles);
+
+impl BitOr<Style> for Style {
+    type Output = Style;
+
+    fn bitor(self, rhs: Style) -> Self::Output {
+        Style(self.0 | rhs.0)
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitOr, bitor for Style, Style);
+
+impl BitOr<Styles> for Style {
+    type Output = Style;
+
+    fn bitor(self, rhs: Styles) -> Self::Output {
+        Style(self.0 | rhs.to_u8())
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitOr, bitor for Style, Styles);
+
+impl BitXor<Style> for Style {
+    type Output = Style;
+
+    fn bitxor(self, rhs: Style) -> Self::Output {
+        Style(self.0 ^ rhs.0)
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitXor, bitxor for Style, Style);
+
+impl BitXor<Styles> for Style {
+    type Output = Style;
+
+    fn bitxor(self, rhs: Styles) -> Self::Output {
+        Style(self.0 ^ rhs.to_u8())
+    }
+}
+
+auto_impl_ref_binop_trait!(impl BitXor, bitxor for Style, Styles);
+
+impl Not for Style {
+    type Output = Style;
+
+    fn not(self) -> Self::Output {
+        Style(!self.0)
+    }
+}
+
+impl Not for &Style {
+    type Output = Style;
+
+    fn not(self) -> Self::Output {
+        Style(!self.0)
+    }
+}
+
+impl_assign_op_trait!(BitAndAssign, bitand_assign for Style, using BitAnd::bitand);
+
+impl_assign_op_trait!(BitOrAssign, bitor_assign for Style, using BitOr::bitor);
+
+impl_assign_op_trait!(BitXorAssign, bitxor_assign for Style, using BitXor::bitxor);
+
+impl Default for Style {
+    fn default() -> Self {
+        CLEAR
+    }
+}
+
+impl From<Styles> for Style {
+    fn from(value: Styles) -> Self {
+        Style(value.to_u8())
+    }
+}
+
+impl From<&Styles> for Style {
+    fn from(value: &Styles) -> Self {
+        Style(value.to_u8())
+    }
+}
+
+impl FromIterator<Styles> for Style {
+    fn from_iter<T: IntoIterator<Item = Styles>>(iter: T) -> Self {
+        let mut style = Style::default();
+        for styles in iter.into_iter() {
+            style.add(styles);
+        }
+        style
+    }
 }
 
 #[cfg(test)]
@@ -290,4 +722,120 @@ mod tests {
         assert_eq!(style.contains(Styles::Italic), true);
         assert_eq!(style.contains(Styles::Dimmed), false);
     }
+
+    mod style_bitwise_logic {
+        use super::*;
+
+        macro_rules! check_impl {
+            ($lh:expr, $method:path, $rh:expr => $res:expr) => {
+                assert_eq!($method($lh, $rh), $res);
+                assert_eq!($method(&$lh, $rh), $res);
+                assert_eq!($method($lh, &$rh), $res);
+                assert_eq!($method(&$lh, &$rh), $res);
+            };
+        }
+
+        macro_rules! check_impl_reflexive {
+            ($lh:expr, $method:path, $rh:expr => $res:expr) => {
+                check_impl!($lh, $method, $rh => $res);
+                check_impl!($rh, $method, $lh => $res);
+            }
+        }
+
+        /// TTABLE = TRUTH_TABLE
+        const TTABLE: (u8, u8) = (0b0101, 0b0011);
+
+        #[test]
+        fn binops() {
+            let tstyle_l = Style(TTABLE.0);
+            let tstyle_r = Style(TTABLE.1);
+            let and_res = Style(TTABLE.0 & TTABLE.1);
+            let or_res = Style(TTABLE.0 | TTABLE.1);
+            let xor_res = Style(TTABLE.0 ^ TTABLE.1);
+
+            check_impl!(tstyle_l, BitAnd::bitand, tstyle_r => and_res);
+            check_impl!(tstyle_l, BitOr::bitor, tstyle_r => or_res);
+            check_impl!(tstyle_l, BitXor::bitxor, tstyle_r => xor_res);
+        }
+
+        #[test]
+        fn binops_with_styles() {
+            let bold_underline = Style(0b0011);
+
+            check_impl_reflexive!(
+                bold_underline,
+                BitAnd::bitand,
+                Styles::Bold
+                => Style(0b0000_0001)
+            );
+            check_impl_reflexive!(
+                bold_underline,
+                BitOr::bitor,
+                Styles::Reversed
+                => Style(0b0000_0111)
+            );
+            check_impl_reflexive!(
+                bold_underline,
+                BitXor::bitxor,
+                Styles::Underline
+                => Style(0b0000_0001)
+            );
+        }
+
+        #[test]
+        fn not() {
+            let not_bold = !Style(BOLD);
+            assert!(!not_bold.contains(Styles::Bold));
+            assert!(not_bold.contains(Styles::Strikethrough));
+            assert_eq!(!Style(0b0011_0101), Style(0b1100_1010));
+        }
+
+        #[test]
+        fn assign_ops() {
+            let original_style = Style(0b0011);
+            let op_style = Style(0b0101);
+
+            let mut style = original_style;
+            style &= op_style;
+            assert_eq!(style, Style(0b0001));
+
+            style = original_style;
+            style |= op_style;
+            assert_eq!(style, Style(0b0111));
+
+            style = original_style;
+            style ^= op_style;
+            assert_eq!(style, Style(0b0110));
+        }
+
+        #[test]
+        fn styles_binops() {
+            check_impl!(
+                Styles::Bold,
+                BitAnd::bitand,
+                Styles::Bold
+                => Style(0b0000_0001)
+            );
+            // The check_impl is only to verify it works with all the combos
+            // of refs. We already know it compines so let's spare ourselves
+            // the extra assertions.
+            assert_eq!(Styles::Bold & Styles::Underline, Style(0b0000_0000));
+
+            check_impl!(
+                Styles::Bold,
+                BitOr::bitor,
+                Styles::Underline
+                => Style(0b0000_0011)
+            );
+            assert_eq!(Styles::Bold | Styles::Bold, Style(0b0000_0001));
+
+            check_impl!(
+                Styles::Bold,
+                BitXor::bitxor,
+                Styles::Underline
+                => Style(0b0000_0011)
+            );
+            assert_eq!(Styles::Bold ^ Styles::Bold, Style(0b0000_0000));
+        }
+    }
 }
